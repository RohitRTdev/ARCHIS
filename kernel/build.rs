use std::env;
use std::fs::{self, File};
use std::io::{BufRead, BufReader, Write};
use std::path::{Path, PathBuf};
use std::process::Command;
use std::collections::HashSet;

use walkdir::WalkDir;
    
const MAX_VECTORS: usize = 256;

#[cfg(target_arch="x86_64")]
fn generate_interrupt_stubs(arch: &str, is_test: bool) {
    let mut output_rs = File::create(format!("src/hal/{}/asm/int_stub.rs", arch)).expect("Cannot create int_stub.rs");
    let mut output_asm = File::create(format!("src/hal/{}/asm/int_stub.S", arch)).expect("Cannot create int_stub.S");

    const GEN_MSG: &'static str = "// This file is automatically generated\n// Do not edit this manually";
    const ALIGNMENT_OFFSET: &'static str = "addq $8, %rsp\n\t";
    let mut error_code_excp = HashSet::<usize>::new();
    error_code_excp.insert(8);    // Double fault
    error_code_excp.insert(10);   // Invalid TSS
    error_code_excp.insert(11);   // Segment-not-present
    error_code_excp.insert(12);   // Stack invalid
    error_code_excp.insert(13);   // General protection
    error_code_excp.insert(14);   // Page fault
    error_code_excp.insert(17);   // Alignment check
    error_code_excp.insert(21);   // Control protection
    error_code_excp.insert(28);   // HC 
    error_code_excp.insert(29);   // VC 
    error_code_excp.insert(30);   // SX
    
    writeln!(output_asm, "{}", GEN_MSG).unwrap();
    writeln!(output_asm, "#include \"asm_macros.inc\"").unwrap();
    writeln!(output_asm, ".extern interrupt_context_save").unwrap();
    
    writeln!(output_rs, "{}", GEN_MSG).unwrap();
    writeln!(output_rs, "extern \"C\" {{").unwrap();
 
    for vector in 0..MAX_VECTORS {
        let offset_str = if error_code_excp.contains(&vector) {
            ALIGNMENT_OFFSET
        }
        else {
            ""
        };
        writeln!(output_asm, "FUNC vec{}_int_stub\n\t{}pushq ${}\n\tjmp interrupt_context_save\nENDF vec{}_int_stub", vector, offset_str, vector, vector).unwrap();
        writeln!(output_rs, "\tfn vec{}_int_stub();", vector).unwrap();    
    }

    writeln!(output_rs, "}}").unwrap();

    if is_test {
        writeln!(output_rs, "unsafe extern \"C\" fn default_int_stub() {{}}").unwrap();
    }
    
    writeln!(output_rs, "pub static IDT_TABLE: [unsafe extern \"C\" fn(); super::super::MAX_INTERRUPT_VECTORS] = [").unwrap();


    for vector in 0..MAX_VECTORS-1 {
        if is_test {
            writeln!(output_rs, "\tdefault_int_stub,").unwrap();
        }
        else {
            writeln!(output_rs, "\tvec{}_int_stub,", vector).unwrap();
        } 
    }
    
    if is_test {
        writeln!(output_rs, "\tdefault_int_stub").unwrap();
    }
    else {
        writeln!(output_rs, "\tvec{}_int_stub", MAX_VECTORS-1).unwrap();
    } 
    
    writeln!(output_rs, "];").unwrap();
}

fn generate_stubs(arch: &str) {
    let input = File::open(format!("src/hal/{}/asm/real.rs", arch)).expect("Assembly stub file not found");
    let reader = BufReader::new(input);

    let mut output = File::create(format!("src/hal/{}/asm/stub.rs", arch)).expect("Cannot create stub.rs");
    writeln!(output, "#![allow(unused_variables)]").unwrap();

    for line in reader.lines() {
        let mut line = line.unwrap().trim().to_string();

        if line.starts_with("pub fn") {
            line.insert_str(4, "unsafe ");
            let without_semicolon = line.trim_end_matches(';');
            writeln!(output, "{without_semicolon} {{").unwrap();

            if line.contains("!") {
                writeln!(output, "  loop{{}}").unwrap();
            }
            else if line.contains("->") {
                writeln!(output, "  0").unwrap();
            }

            writeln!(output, "}}\n").unwrap();
        }
    }
}

fn assemble_and_link(path: &Path, out_dir: &Path, asm_dir: &Path, target: &str) {
    let stem = path.file_stem().unwrap().to_string_lossy();
    let obj = out_dir.join(format!("{stem}.o"));
    let input_path = path.to_str().unwrap().replace('\\', "/"); 
    println!("cargo:rerun-if-changed={}", path.display());

    let status = Command::new("clang")
        .args([
            "-c",
            "-fPIC",
            "-target", target,
            "-I", asm_dir.to_str().unwrap(),
            "-o", obj.to_str().unwrap(),
            &input_path
        ])
        .status()
        .expect("Failed to run clang");

    assert!(status.success(), "Assembly failed: {}", path.display());

    println!("cargo:rustc-link-arg={}", obj.display());
}

fn build_trampoline(path: &Path, out_dir: &Path, asm_dir: &Path, target: &str) {
    let obj = out_dir.join("trampoline.o");
    let bin = out_dir.join("trampoline.bin");
    let input_path = path.to_str().unwrap().replace('\\', "/"); 
    let offsets_rs = asm_dir.join("trampoline_offsets.rs")
    .to_str().unwrap().replace('\\', "/"); 
    
    println!("cargo:rerun-if-changed={}", path.display());
    let status = Command::new("clang")
        .args([
            "-c",
            "-target", target,
            "-I", asm_dir.to_str().unwrap(),
            "-o", obj.to_str().unwrap(),
            &input_path
        ])
        .status()
        .expect("Failed to assemble trampoline");

    assert!(status.success(), "Trampoline assembly failed");

    generate_trampoline_offsets(&obj, &offsets_rs);

    let status = Command::new("llvm-objcopy")
        .args([
            "-O", "binary",
            obj.to_str().unwrap(),
            bin.to_str().unwrap(),
        ])
        .status()
        .expect("failed to run llvm-objcopy");

    assert!(status.success(), "objcopy failed");

    // Export paths
    println!("cargo:rustc-env=TRAMPOLINE_BIN={}", bin.display());
}

fn generate_trampoline_offsets(obj: &Path, out: &str) {
    let output = Command::new("llvm-nm")
        .args(["-n", obj.to_str().unwrap()])
        .output()
        .expect("Failed to run llvm-nm");

    assert!(output.status.success(), "llvm-nm failed");

    let mut contents = String::new();
    contents.push_str("// This file is automatically generated\n// Do not edit this manually\n");
    contents.push_str("// Trampoline symbol offsets\n\n");

    for line in String::from_utf8_lossy(&output.stdout).lines() {
        // Example:
        // 0000000000000078 D pml4_phys
        let mut parts = line.split_whitespace();
        let addr = parts.next();
        let _kind = parts.next();
        let name = parts.next();

        if let (Some(addr), Some(name)) = (addr, name) {
            let offset = usize::from_str_radix(addr, 16).unwrap();
            contents.push_str(&format!(
                "pub const {}: usize = 0x{:x};\n",
                name.to_uppercase(),
                offset
            ));
        }
    }

    fs::write(out, contents).expect("Failed to write trampoline_offsets.rs");
}

fn build_acpica(out_dir: &Path, target: &str) {
    let acpica_src = Path::new("src/acpica/acpica_c");
    let mut c_files = Vec::new();
    for entry in WalkDir::new(acpica_src)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().map(|ext| ext == "c").unwrap_or(false))
    {
        println!("cargo:rerun-if-changed={}", entry.path().display());
        c_files.push(entry.path().to_owned());
    }

    for file in &c_files {
        let file_stem = file.file_stem().unwrap().to_string_lossy();
        let obj_path = out_dir.join(format!("{}.o", file_stem));

        let status = Command::new("clang")
            .args(&[
                "-c",
                "-fPIC",
                "-O2",
                "-msoft-float",
                "-mno-sse",
                "-mno-sse2",
                "-mno-avx",
                "-mno-mmx",
                "-fno-tree-vectorize",
                "-fno-vectorize",
                "-fno-slp-vectorize",
                "-fno-builtin",
                "-nostdlib",
                "-ffreestanding",
                "-fno-lto",
                "-Isrc/acpica/acpica_c/include",
                "-target", &target,
                file.to_str().unwrap(),
                "-o",
                obj_path.to_str().unwrap(),
            ])
            .status()
            .expect("Failed to run clang");

        if !status.success() {
            panic!("Failed to compile {:?}", file);
        }

        println!("cargo:rustc-link-arg={}", obj_path.display());
    }
}


fn main() {
    let arch = env::var("CARGO_CFG_TARGET_ARCH").unwrap();
    let is_test = Path::new("placeholder_test.txt").exists();
    
    // Just set a dummy var so that test build won't complain
    println!("cargo:rustc-env=TRAMPOLINE_BIN=asm/test_trampoline.txt");

    generate_interrupt_stubs(&arch, is_test);
    generate_stubs(&arch);
    if is_test {
        println!("cargo:warning=Skipping build.rs logic during tests.");
        return;
    }
    
    let target = format!("{}-unknown-none", arch);
    println!("cargo:rerun-if-changed=src/hal/{}/asm", arch);
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    let asm_dir = PathBuf::from(format!("src/hal/{}/asm", arch));
    println!("Compiling assembly files from directory: {}", asm_dir.display());
    for entry in fs::read_dir(&asm_dir).unwrap().flatten() {
        let path = entry.path();
        if path.extension().map_or(false, |e| e == "S") {
            let file_stem = path.file_stem().unwrap();
            
            if file_stem == "trampoline" {
                build_trampoline(&path, &out_dir, &asm_dir, &target);
            } else {
                assemble_and_link(&path, &out_dir, &asm_dir, &target);
            } 
        }
    }
    
    if env::var("CARGO_FEATURE_ACPI").is_ok() {
        println!("Building acpica files from source");
        build_acpica(out_dir.as_path(), target.as_str());
    } 

}