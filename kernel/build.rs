use std::env;
use std::fs::{self, File};
use std::io::{BufRead, BufReader, Write};
use std::path::{Path, PathBuf};
use std::process::Command;
use std::collections::HashSet;
    
const MAX_VECTORS: usize = 256;

#[cfg(target_arch="x86_64")]
fn generate_interrupt_stubs(arch: &str, is_test: bool) {
    let mut output_rs = File::create(format!("src/hal/{}/asm/int_stub.rs", arch)).expect("Cannot create int_stub.rs");
    let mut output_asm = File::create(format!("src/hal/{}/asm/int_stub.S", arch)).expect("Cannot create int_stub.S");

    const GEN_MSG: &'static str = "// This file is automatically generated\n// Do not edit this manually";
    const ALIGNMENT_OFFSET: &'static str = "addq $8, %rsp\n\t";
    let mut error_code_excp = HashSet::<usize>::new();
    error_code_excp.insert(8);    // Double fault
    error_code_excp.insert(10);   // Invalid TSS
    error_code_excp.insert(11);   // Segment-not-present
    error_code_excp.insert(12);   // Stack invalid
    error_code_excp.insert(13);   // General protection
    error_code_excp.insert(14);   // Page fault
    error_code_excp.insert(17);   // Alignment check
    error_code_excp.insert(21);   // Control protection
    error_code_excp.insert(28);   // HC 
    error_code_excp.insert(29);   // VC 
    error_code_excp.insert(30);   // SX
    
    writeln!(output_asm, "{}", GEN_MSG).unwrap();
    writeln!(output_asm, "#include \"asm_macros.inc\"").unwrap();
    writeln!(output_asm, ".extern interrupt_context_save").unwrap();
    
    writeln!(output_rs, "{}", GEN_MSG).unwrap();
    writeln!(output_rs, "extern \"C\" {{").unwrap();
 
    for vector in 0..MAX_VECTORS {
        let offset_str = if error_code_excp.contains(&vector) {
            ALIGNMENT_OFFSET
        }
        else {
            ""
        };
        writeln!(output_asm, "FUNC vec{}_int_stub\n\t{}pushq ${}\n\tjmp interrupt_context_save\nENDF vec{}_int_stub", vector, offset_str, vector, vector).unwrap();
        writeln!(output_rs, "\tfn vec{}_int_stub();", vector).unwrap();    
    }

    writeln!(output_rs, "}}").unwrap();

    if is_test {
        writeln!(output_rs, "unsafe extern \"C\" fn default_int_stub() {{}}").unwrap();
    }
    
    writeln!(output_rs, "pub static IDT_TABLE: [unsafe extern \"C\" fn(); super::super::MAX_INTERRUPT_VECTORS] = [").unwrap();


    for vector in 0..MAX_VECTORS-1 {
        if is_test {
            writeln!(output_rs, "\tdefault_int_stub,").unwrap();
        }
        else {
            writeln!(output_rs, "\tvec{}_int_stub,", vector).unwrap();
        } 
    }
    
    if is_test {
        writeln!(output_rs, "\tdefault_int_stub").unwrap();
    }
    else {
        writeln!(output_rs, "\tvec{}_int_stub", MAX_VECTORS-1).unwrap();
    } 
    
    writeln!(output_rs, "];").unwrap();
}

fn generate_stubs(arch: &str) {
    let input = File::open(format!("src/hal/{}/asm/real.rs", arch)).expect("Assembly stub file not found");
    let reader = BufReader::new(input);

    let mut output = File::create(format!("src/hal/{}/asm/stub.rs", arch)).expect("Cannot create stub.rs");
    writeln!(output, "#![allow(unused_variables)]").unwrap();

    for line in reader.lines() {
        let mut line = line.unwrap().trim().to_string();

        if line.starts_with("pub fn") {
            line.insert_str(4, "unsafe ");
            let without_semicolon = line.trim_end_matches(';');
            writeln!(output, "{without_semicolon} {{").unwrap();

            if line.contains("!") {
                writeln!(output, "  loop{{}}").unwrap();
            }
            else if line.contains("->") {
                writeln!(output, "  0").unwrap();
            }

            writeln!(output, "}}\n").unwrap();
        }
    }
}

fn main() {
    let arch = env::var("CARGO_CFG_TARGET_ARCH").unwrap();
    let is_test = Path::new("placeholder_test.txt").exists();
    generate_interrupt_stubs(&arch, is_test);
    generate_stubs(&arch);
    if is_test {
        println!("cargo:warning=Skipping build.rs logic during tests.");
        return;
    }
    
    let target = format!("{}-unknown-none", arch);
    println!("cargo:rerun-if-changed=src/hal/{}/asm", arch);
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    let asm_dir = PathBuf::from(format!("src/hal/{}/asm", arch));
    println!("Compiling assembly files from directory: {}", asm_dir.display());

    for entry in fs::read_dir(&asm_dir).unwrap().flatten() {
        let path = entry.path();
        if path.extension().map_or(false, |e| e == "S") {
            let file_stem = path.file_stem().unwrap();
            let output_obj = out_dir.join(format!("{}.o", file_stem.to_string_lossy()));
            let input_path = path.to_str().unwrap().replace('\\', "/");
            
            let status = Command::new("clang")
                .args(&[
                    "-c",
                    "-fPIC",                   
                    "-target", &target,
                    "-I", asm_dir.to_str().unwrap(),
                    "-o", output_obj.to_str().unwrap(),
                    &input_path,
                ])
                .status()
                .expect("failed to execute assembler");

            assert!(status.success(), "Failed to assemble {}", path.display());

            // Tell cargo to link the object file
            println!("cargo:rustc-link-arg={}", output_obj.display());
        }
    }
}